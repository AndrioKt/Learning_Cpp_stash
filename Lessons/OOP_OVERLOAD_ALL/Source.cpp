#include <iostream>
#include <conio.h>
#include <string>
#include <cassert>
using namespace std;

//-----------------------------------------------
//----------Перегрузки операций в классах--------
//-----------------------------------------------

class Human//простейше реализованный класс, с публичным доступом
{
public:
	int age;
	int weight;
	string name;
	void Print()
	{
		cout << "Name " << name << "\nWeight " << weight << "\n Age " << endl << endl;
	}
};
class Point //класс с координатами точки в декартовой системе координат
{
	int x;
	int y;

public:

	Point()//конструктор по умолчанию
	{
		x = 0;
		y = 0;
		cout << this << " default constructor "<< endl;
	}
	Point(int valueX, int valueY)
	{
		x = valueX;
		y = valueY;
		cout << this << " personal constructor "<< endl;
	}

	void SetY(int y)
	{
		this->y = y;
	}
	int GetY()
	{
		return y;
	}
	void SetX(int valueX)
	{
		this->x = x;
	}
	int GetX()
	{
		return x;
	}
//!!!!!Перегрузим операцию равенства:
bool operator == (const Point& other)//оператор равенства всегда должен принимать то, чему он должен быть равен(в нашем случае объекту b, c ссылкой)
{
	//В упрощенном виде (так не стоит писать в целях оптимизации)
	/*
	if (this->x == other.x and this->y == other.y)
		return true;
	else return false;
	*/
	//В правильном оптимизированном виде:
	return this->x == other.x and this->y == other.y;//т.к выражение само по себе вернет либо true либо false, и вернет результат вычесления
}
//!!!!!Перегрузим операцию не равенства:
bool operator != (const Point& other)//оператор равенства всегда должен принимать то, чему он должен быть равен(в нашем случае объекту b, c ссылкой)
{
//аналогиче6н перегрузке равенство, но с инвертированием всего результата
	return !(this->x == other.x and this->y == other.y);//представляет из себя инвертирование перегрузки равенства
}
//!!!!!Перегрузим операцию больше или равно:
bool operator >= (const Point& other)//оператор равенства всегда должен принимать то, чему он должен быть равен(в нашем случае объекту b, c ссылкой)
{
	return this->x >= other.x and this->y >= other.y;//т.к выражение само по себе вернет либо true либо false, и вернет результат вычесления
}
//!!!!!Перегрузим операцию меньше или равно:
bool operator <= (const Point& other)//оператор равенства всегда должен принимать то, чему он должен быть равен(в нашем случае объекту b, c ссылкой)
{
	return this->x <= other.x and this->y <= other.y;//т.к выражение само по себе вернет либо true либо false, и вернет результат вычесления
}
//!!!!!Перегрузим операцию СЛОЖЕНИЯ: (без конструктора копирования и присваивания не будет работать с динамической памятью)
Point operator+ (const Point & other) // при сложении нужно возвращать именно копию Point, а не ссылка или указатель на него
{
	Point temp;
	temp.x = this->x + other.x; //таким образом в новую временную переменную мы помещаем результат сложения х и у текущего обьекта и обьекта с которым сравниваем(складываем)
	temp.y = this->y + other.y;
	return temp;//возвращаем нашу переменную с обоими параметрами х и у
}
//!!!!!Перегрузим операцию ВЫЧИТАНИЯ:
Point operator- (const Point& other) // при сложении нужно возвращать именно копию Point, а не ссылка или указатель на него
{
	Point temp;
	temp.x = this->x - other.x; //таким образом в новую временную переменную мы помещаем результат вычитания х и у текущего обьекта и обьекта с которым сравниваем(складываем)
	temp.y = this->y - other.y;
	return temp;//возвращаем нашу переменную с обоими параметрами х и у
}
//!!!!!Перегрузим операцию ИНКРЕМЕНТА:(у префиксного приоритет самый высокий, у постфиксного - самая низкая)
//префиксная форма ++a:
Point & operator++() //нужно возвращать данные по ссылке, тк работаем с тем же обьектом а не его копией
{ 
	this->x++;//перегрузить можно и так
	this->y+=1; // и так
	return *this;//возвращать надо ссылку текущий обьект, т.к this указатель, то его нужно разименовать
}
//постфиксная форма a++:
Point & operator++(int value)//в постфиксной форме требуется принимать параметр (при этом он никогда не принимается, а нужен лишь для отличия от префиксной формы)
{
	Point temp(*this);//создадим переменную с точно такими же параметрами вызова, его мы будет возвращать (например для присвоения чему нибудь), и лишь потом делать инкремент
	this->x++;
	this->y++; 
	return temp;//возвращаем первоначальную переменную, и лишь потом уже произойдет сложение
}
//Перегрузка декремента делается эдентично инкременту, только с -
//!!!!!!!! Перегрузим операцию вывода в поток <<
friend ostream& operator<< (ostream &out, const Point &point)//здесь мы возвращаем потоковую переменную out, в которую перегружаем то, что хотим вывести в поток
{
	out << "Point(" << point.x << "," << point.y << ")";
	return out;
}
//!!!!!!!! Перегрузим операцию ввода в поток >>
friend istream& operator>> (istream& in, Point& point)//перегружаем для возможности ввода в поток параметров обьектов класса ВАЖНО ЧТО БЫ POINT БЫЛ НЕ КОНСТАНТНЫМ
{
	in>>point.x;
	in>>point.y;

	return in;
}
};

//Перегрузка унарных операторов +,- и ! производится не дружественной функцией а методом класса
//Так же стоит перегружать методом класса операторы индексирования [] и скобок ()
class TestClass
{
	double m_a, m_b, m_c;
	int arr[5]{5,44,4,978,69};//внутри классов всегда количество элементов требуется указывать явно
public:
	TestClass(double a = 0.0, double b = 0.0, double c = 0.0 ) :m_a(a), m_b(b), m_c(c) {}
//!!!!!! Перегрузим унарный - (перегрузка унарного+ аналогична)
	TestClass operator -()const
	{
		return TestClass(-m_a, -m_b, -m_c);// таким образом унарный - будет конвертировать обьект класса в отрицательный (какие именно параметры конвертировать зависит от возврата в перегрузке)
	}
	//!!!!!! Перегрузим операцию НЕ !(отрицание)
	bool operator! ()const
	{
		return(m_a == 0.0 and m_b == 0.0 and m_c == 0.0);
	}

//Перегрузка оператора ИНДЕКСИРОВАНИЯ []:
	int& operator[](int index)//тк индексирование принимает оператор размера/ячейки, то и передавать нужно индекс
	{//возвращаем значение по ссылке, что бы было возможно присваивать в ячейки значения
		return arr[index];
	}
};


//Перегрузка оператора круглых скобок() может производиться с любым количеством переменных. Производится перегрузка всегда через методы класса
//Чаще всего это используется при получении доступа к матрицам
class Matrix
{
	double data[5][5];
public:
	Matrix()
	{
		//присвоим всем элементам матрицы значение 0
		for (int row = 0; row < 5; row++)
		{
			for (int col = 0; col < 5; col++)
			{
				data[row][col] = 0;
			}
		}
	}
		double& operator()(int row, int col);
		const	double& operator()(int row, int col) const;//то же самое, только для константных обьектов
};
	double& Matrix::operator() (int row, int col)
	{
		assert(col >= 0 and col < 5);//запишем условие, при котором колонки и строки должны быть в диапазоне нашей матрицы
		assert(row >= 0 and row < 5);
		return data[row][col];
	}
	const double& Matrix::operator() (int row, int col) const
	{
		assert(col >= 0 and col < 5);//запишем условие, при котором колонки и строки должны быть в диапазоне нашей матрицы
		assert(row >= 0 and row < 5);
		return data[row][col];
	}


int main()
{
	Point a(5, 1);
	Point b(9, 4);
	
	Point c = a + b;//присвоим в с результат сложения обьектов с параметрами х и у
	++a;
	bool result = a <= b; //(результат сравнения величин всегда либо true либо false, поэтому можно сразу присвоить результат сравнения)
	cout << endl<< endl<< result << endl;
	TestClass e;//обьявим новый обьект класса с массивом и индексацией
	cout << endl << endl << e[1] << endl;//выведем 1 элемент массива
	e[1] = 100; //благодаря передани по ссылке(а не копии обьекта) мы можем менять любые значения
	cout << endl << endl << e[1] << endl;//выведем 1 элемент массива
	cout <<a << endl<< b << endl;//проверка перегрузки вывода

	if (!e)//проверка оператора отрицания, где если обьект е нулевой то выведет что он равен нулю, иначе не равен
		cout << "e is 0";
	else cout << "e is not 0";

	//проверим перегрузку оператора ()
	Matrix matrix;
	matrix(2, 3) = 3.6;// присвоим в элемент значение
	cout << matrix(2, 3);//выведем в консоль значение этого элемента
	return 0;
}
