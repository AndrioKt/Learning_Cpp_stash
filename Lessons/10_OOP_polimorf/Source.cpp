#include <iostream>
#include <conio.h>
#include <string>
#include <cassert>
using namespace std;

//------------------------
//----Полиморфизм---------
//---Виртуальные функции---
//-------------------------

class Gun//в идеале тут должен быть абстрактный класс вооружения
{
public:
	virtual void shoot()//создадим виртуальный метод, виртуальность позволит переопределить работу функции в классе наследнике
	{
		cout << "BANG!" << endl;
	}
};

class SubmachineGun:public Gun //создаем наследуемый класс пистолет-пулемет
{
public:
	 void shoot()override//ключевое слово override не обязательно, но используетс я для контроля над ошибками. Оно жестко указывает что мы перезаписывает метод shoot из базового класса
	{
		cout << "BANG!BANG!BANG!" << endl;
	}
};
class GranadeLauncher :public Gun // далее создавая новые наследуемые классы мы можем без проблем создавать новые классы, без необходимости с нуля переписывать реализации каждого следующего оружия
{
public:
	void shoot() override
	{
		cout << "BOOM!" << endl;
	}
};

//далее создадим героя, который так же может стрелять
class Player
{
public:
	void shoot(Gun* gun) //создадим метод "стрелять", и передадим ссылку на оружие из которого он должен стрелять
	{
		gun->shoot();
	
	}
};
int main()
{
	Gun gun;
	GranadeLauncher granade;
	SubmachineGun machineGun;
	//Полиморфизм заключается в возможности переопределении методов класса в соответствии с тем, на что указывает ссылка (для смены поведения классов наследников)
	//Gun* weapon = &machineGun;//таким образом мы можем создать обьект класса Gun, но ссылаться на machineGun, благодаря чему произойдет переопределение метода соответственно класу machineGun
	//это позволит например выбрать выполнение методов в соответствии с текущим выбранным оружием
	Player player;//создадим персонажа
	player.shoot(&granade);//при вызове метода можно выбирать то, из чего именно персонаж будет стрелять
	return 0;
}