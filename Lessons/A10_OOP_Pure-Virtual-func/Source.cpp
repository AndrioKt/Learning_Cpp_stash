#include <iostream>
#include <conio.h>
#include <string>
#include <cassert>
using namespace std;

//------------------------
//----Полиморфизм---------
//----Абстрактные классы-----
//-Чистые виртуальные функции-
//-------------------------



//Абстрактные классы, это классы в которых не описана никакая реализация
//Создадим абстрактный класс, который будет содержать все возможные чисто виртуальные методы, которые в дальнейшем можно будет переопределять
class Weapon//абстрактный класс не требуется обьявлять при создании обьектов
{
public:
	virtual void shoot() = 0;//создадим чисто виртуальный метод, без реализации, что бы в каждом следующем классе (оружии) на него ссылаться и переопределять действия
 // создание чистого виртуального метода осуществляется присвоением в метод нуля, вместо реализации 
	// Так же в абстрактных классах можно создавать полностью рабочие реализации(не виртуальные), которые будут в итоге применяться ко всем наследуемым классам
	void Foo()
	{
		cout << "Enemy killed" << endl;
	}
};

class Gun :public Weapon
{
public:
	void shoot() override//создадим виртуальный метод, виртуальность позволит переопределить работу функции в классе наследнике
	{
		cout << "BANG!" << endl;
	}
};

class SubmachineGun :public Gun //создаем наследуемый класс пистолет-пулемет
{
public:
	void shoot()override//ключевое слово override не обязательно, но используетс я для контроля над ошибками. Оно жестко указывает что мы перезаписывает метод shoot из базового класса
	{
		cout << "BANG!BANG!BANG!" << endl;
	}
};
class GrenadeLauncher :public Weapon // далее создавая новые наследуемые классы мы можем без проблем создавать новые классы, без необходимости с нуля переписывать реализации каждого следующего оружия
{
public:
	void shoot() override
	{
		cout << "BOOM!" << endl;
	}
};

class Knife :public Weapon // далее создавая новые наследуемые классы мы можем без проблем создавать новые классы, без необходимости с нуля переписывать реализации каждого следующего оружия
{
public:
	void shoot() override
	{
		cout << "Zweek!" << endl;
	}
};
//далее создадим героя, который так же может стрелять
class Player
{
public:
	void shoot(Weapon* weapon) //создадим метод "стрелять", и передадим ссылку на оружие из которого он должен стрелять
	{
		weapon->shoot();
	}
};
int main()
{
	Gun gun;
	GrenadeLauncher grenade;
	//grenade.Foo(); в итоге реализацию функции описанную в абстрактном классе можно использовать с любого обьекта класса наследника
	SubmachineGun machineGun;
	Knife knife;
	//Полиморфизм заключается в возможности переопределении методов класса в соответствии с тем, на что указывает ссылка (для смены поведения классов наследников)
	//Gun* weapon = &machineGun;//таким образом мы можем создать обьект класса Gun, но ссылаться на machineGun, благодаря чему произойдет переопределение метода соответственно класу machineGun
	//это позволит например выбрать выполнение методов в соответствии с текущим выбранным оружием
	Player player;//создадим персонажа
	player.shoot(&knife);//при вызове метода можно выбирать то, из чего именно персонаж будет стрелять
	return 0;
}