#include <iostream>
#include <cassert> 
#include <fstream> 
#include <windows.h> 
using namespace std;

class Point
{

public:
	int x;
	int y;
	int z;
	Point() { x = y = z = 0; }
	Point(int x, int y, int z)
	{
		this->x = x;
		this->y = y;
		this->z = z;
	}

	void Print()
	{
		cout << "X: " << x << "\tY: " << y << "\tZ:" << z << endl;

	}

};

int main()
{
	setlocale(LC_ALL, "ru");
	// -----------------------------------------------------------------
	// ----------------Запись и считывание объектов класов в файл-------
	//------------------------------------------------------------------

	string path = "myFile.txt"; //зададим переменную отвечающую за путь до файла
/*
	ofstream fout;

	fout.open(path, ofstream::app); //здесь мы производим открытие файла, app отвечает за продолжение записи в конец документа(а не перезаписывание)
Point point(104, 44, 25);
	point.Print();

	if (!fout.is_open()) //здесь делаем проверку открылся ли файл
		cout << "Error of opening!" << endl;
	else
	{
		cout << "File is open!" << endl;
		fout.write((char*)& point, sizeof(Point));//побайтово запишем в поток данные
	}

fout.close();//закроем файл для экономии ресурсов
	ifstream fin;
	fin.open(path);

	if (!fin.is_open()) //здесь делаем проверку открылся ли файл
		cout << "Error of opening!" << endl;
	else
	{
		cout << "File is open!" << endl;
		Point pnt;//создадим обьект, указатель
		fin.read((char*)& pnt, sizeof(Point));//проведем побитовое считывание. Пока что считывание произойдет только 1 строчки
		//Для считывания всех данных с файла используем:
		while (fin.read((char*)& pnt, sizeof(Point)))//произведем проверку (если получилось считывание то возвращается тру и происходит считывание, если нет то цикл прерывается)
		{
			pnt.Print();//при считывании будем выводить считанные данные
		}

	}
	fout.close();//закроем файл для экономии ресурсов

	*/

	// ---------------------------------------------------------------------------------------
// ----------------Подробная работа с fstream, возможность записи в файл на русском-----------
//---------------------------------------------------------------------------------------------

	fstream fs;
	fs.open(path, fstream::in | fstream::out | fstream::app);//первый аргумент отвечает за путь, второй аргумент за цель выполнения (чтение/запись)
	//в качестве 2го аргумента можно передать несколько параметров, при помощи битового ИЛИ |
	if (!fs.is_open()) //здесь делаем проверку открылся ли файл
		cout << "Error of opening!" << endl;
	else
	{
		int value = 0;
		string msg;//буфер для сообщения
		cout << "File is open!" << endl;
		cout << "Enter 1 if you want to write messages to file" << endl;
		cout << "Enter 2 if you want to read messages from file" << endl;

		cin >> value;//при необходимости добавить првоерку некорректности данных
		if (value == 1)
		{
			
			cout << "Enter your message!" << endl;
			SetConsoleCP(1251);  //Используем эту команду для возможности записи в файл на русском языке. Данная конанда находится в библиотеке Windows.h
			//Для русского языка кодировка 1251
			cin >> msg;
			fs << msg << "\n";
			//После выполнения программы ТРЕБУЕТСЯ вернуть кодировку в значение по умолчанию. Для этого используем код 866
			SetConsoleCP(866);
		}
		if (value == 2)
		{
			while (!fs.eof())//Проверка (пока не конец файла, мы будем получать сообщение)
			{
				msg = "";//Труебуется в начале цикла обнулоять буфер сообщений, иначе последней строкой он будет дублировать сообщение
				fs >> msg;
				cout << msg << endl;
			}
		}
	}
	fs.close();//всегда необходимо освобождать ресурсы закрытием
	return 0;
}

